<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
  <title>MP+RE+DR-2/iphone/title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    body { margin:0; background:#0b0c10; color:#e8e8e8; overflow:hidden; }
    button { font: inherit; }

    /* 顶栏 */
    .topbar{
      position: absolute; top:0; left:0; right:0;
      z-index: 40;
      display:flex; flex-wrap:wrap; gap:8px; align-items:center; justify-content:center;
      padding:10px 10px calc(10px + env(safe-area-inset-top));
      background: linear-gradient(to bottom, rgba(0,0,0,.86), rgba(0,0,0,0));
      pointer-events:none;
    }
    .topbar * { pointer-events:auto; }

    .topbar button{
      padding:8px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.08);
      color:#fff;
      backdrop-filter: blur(10px);
      -webkit-tap-highlight-color: transparent;
      cursor:pointer;
    }
    .topbar button.active{
      border-color: rgba(255,255,255,.75);
      background: rgba(255,255,255,.16);
    }
    .topbar .danger{
      border-color: rgba(255,120,120,.55);
    }
    .topbar .primary{
      border-color: rgba(160,210,255,.60);
    }
    .topbar button.disabled{
      opacity:.45;
      pointer-events:none;
      filter:saturate(.7);
    }

    /* 舞台 */
    #stage{
      position: relative;
      width:100vw;
      height:100vh;
      overflow:hidden;
      touch-action:none;
      background:#000;
      user-select:none;
    }
    #video{
      position:absolute; inset:0;
      width:100%; height:100%;
      object-fit: cover;
      transform-origin:center;
      z-index:1;
    }

    /* loader/hint */
    #loader{
      position:absolute; left:50%; top:50%;
      transform: translate(-50%, -50%);
      z-index: 6;
      color:#aaa;
      font-size: 14px;
      text-align:center;
      line-height:1.35;
      pointer-events:none;
      padding:8px 10px;
      border-radius:12px;
      background: rgba(0,0,0,.35);
      border: 1px solid rgba(255,255,255,.12);
      backdrop-filter: blur(10px);
    }
    #hint{
      position:absolute;
      left:50%;
      bottom: calc(86px + env(safe-area-inset-bottom));
      transform: translateX(-50%);
      z-index: 35;
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 12px;
      color: rgba(255,255,255,0.88);
      background: rgba(0,0,0,0.38);
      border: 1px solid rgba(255,255,255,0.16);
      backdrop-filter: blur(10px);
      pointer-events:none;
      opacity:0;
      transition: opacity .18s;
      max-width: 86vw;
      text-align:center;
      line-height:1.25;
    }
    #hint.show{ opacity:1; }

    /* ROI 可视化框 */
    #roiBox{
      position:absolute;
      border:1px solid rgba(255,255,255,.85);
      background: rgba(255,255,255,.08);
      border-radius:0px;
      pointer-events:none;
      display:none;
      z-index: 9;
    }

    /* 绘制层：显示path */
    #drawLayer{
      position:absolute; inset:0;
      z-index: 8;
      pointer-events:none;
    }

    /* 贴纸 / 冻结窗（统一用 canvas） */
    .sticker{
      position:absolute;
      left:0; top:0;
      z-index: 10;
      border-radius:0px;
      border:1px solid rgba(255,255,255,0);
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
      filter: drop-shadow(0 0 10px rgba(255,255,255,0.45));
      transform-origin: center;
      touch-action:none;
      cursor: grab;
      animation: popIn .28s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }
    .sticker:active{ cursor:grabbing; }
    .sticker.selected{
      border-color: rgba(255,255,255,.9);
      box-shadow: 0 10px 30px rgba(0,0,0,.55);
      outline: 2px solid rgba(255,255,255,0.95);
      outline-offset: 3px;
    }
    @keyframes popIn{
      from { transform: scale(.88); opacity:0; }
      to   { transform: scale(1); opacity:1; }
    }

    /* 编辑条（深度编辑时出现） */
    #editbar{
      position:absolute; left:0; right:0; bottom:0;
      z-index: 50;
      padding: 10px 10px calc(10px + env(safe-area-inset-bottom));
      display:none;
      gap:8px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:center;
      background: linear-gradient(to top, rgba(0,0,0,.92), rgba(0,0,0,0));
      pointer-events:none;
    }
    #editbar *{ pointer-events:auto; }

    .seg{
      display:flex; gap:8px; flex-wrap:wrap; justify-content:center; align-items:center;
      width:100%;
    }
    .pill{
      display:flex; align-items:center; gap:8px;
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.25);
      background: rgba(255,255,255,0.10);
      backdrop-filter: blur(10px);
      font-size: 12px;
      color: #ddd;
    }
    input[type="range"]{ width:140px; }

    /* Library 面板 */
    #libPanel{
      position:absolute;
      right:12px; top:62px;
      z-index: 60;
      width: 190px;
      max-height: 62vh;
      overflow:auto;
      padding:10px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(20,20,24,.78);
      backdrop-filter: blur(10px);
      border-radius: 14px;
      display:none;
    }
    #libPanel h3{
      margin:0 0 8px 0;
      font-size: 12px;
      opacity:.85;
      font-weight:600;
      letter-spacing:.02em;
    }
    .thumb{
      width:100%;
      border-radius:10px;
      border:1px solid rgba(255,255,255,.12);
      margin-bottom:8px;
      display:block;
      cursor:pointer;
      background:#000;
    }
    .row{ display:flex; gap:8px; margin-bottom:8px; }
    .row button{
      flex:1; border-radius:10px; padding:6px 8px;
      border:1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.08);
      color:#fff;
    }
    .small{ font-size:12px; opacity:.8; }
  </style>
</head>

<body>
  <div class="topbar">
    <button id="btnStart" class="primary">Start Camera</button>
    <button id="btnFlip">Flip</button>

    <button id="btnModeMP" class="active">MP</button>
    <button id="btnModeRect">RECT</button>
    <button id="btnModeDraw">DRAW</button>

    <button id="btnSave" class="disabled">Save</button>
    <button id="btnEdit" class="primary disabled">Edit</button>
    <button id="btnLibrary">Library</button>

    <button id="btnUndoObj">Undo Add</button>
    <button id="btnClearAll" class="danger">Clear</button>
  </div>

  <div id="stage">
    <video id="video" playsinline muted autoplay></video>
    <canvas id="drawLayer"></canvas>
    <div id="roiBox"></div>

    <div id="loader">加载模型中…<br/>（加载完后点 Start Camera）</div>
    <div id="hint"></div>

    <div id="libPanel">
      <div class="row">
        <button id="btnLibClose">Close</button>
        <button id="btnLibClear">Clear</button>
      </div>
      <h3>LIBRARY</h3>
      <div id="libList" class="small"></div>
    </div>
  </div>

  <div id="editbar">
    <div class="seg">
      <span class="pill">深度编辑：拖动=拉伸</span>

      <span class="pill">
        半径
        <input id="radius" type="range" min="10" max="220" value="120">
      </span>

      <span class="pill">
        强度
        <input id="strength" type="range" min="-100" max="100" value="85">
      </span>

      <button id="btnUndoPaint">撤销</button>
      <button id="btnDone" class="danger">完成</button>
    </div>
  </div>

  <script type="module">
    import { InteractiveSegmenter, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/vision_bundle.js";

    /* =========================
       Elements
    ========================= */
    const stage = document.getElementById("stage");
    const video = document.getElementById("video");
    const roiBox = document.getElementById("roiBox");
    const drawLayer = document.getElementById("drawLayer");
    const drawCtx = drawLayer.getContext("2d");
    const loader = document.getElementById("loader");
    const hint = document.getElementById("hint");

    const editbar = document.getElementById("editbar");
    const radiusEl = document.getElementById("radius");
    const strengthEl = document.getElementById("strength");

    const libPanel = document.getElementById("libPanel");
    const libList  = document.getElementById("libList");

    const btnSave = document.getElementById("btnSave");
    const btnEdit = document.getElementById("btnEdit");

    /* =========================
       UI helpers
    ========================= */
    const showHint = (text, ms=900) => {
      hint.textContent = text;
      hint.classList.add("show");
      clearTimeout(showHint._t);
      showHint._t = setTimeout(() => hint.classList.remove("show"), ms);
    };

    function setActionEnabled(enabled){
      btnSave.classList.toggle("disabled", !enabled);
      btnEdit.classList.toggle("disabled", !enabled);
    }

    /* =========================
       Global state
    ========================= */
    let stream = null;
    let facingMode = "environment"; // environment | user

    let captureMode = "mp"; // mp | rect | draw
    let pointerDown = false;
    let startPt = null;
    let roi = null;      // {x,y,w,h} stage css px
    let path = [];       // [{x,y},...]

    // stickers
    let stickers = [];   // { el, x,y,w,h, scale, rot }
    let selected = null;

    // Editing
    let editMode = "stretch"; // only stretch now
    let paintUndoStack = []; // imageData stack for selected canvas (liquify)

    // Object-level undo (remove last added sticker)
    let objUndoStack = [];

    // MediaPipe
    let interactiveSegmenter = null;
    let isProcessing = false;

    // Two-finger gesture for transform selected
    let gesture = {
      active:false,
      startDist:0,
      startAng:0,
      baseScale:1,
      baseRot:0
    };

    // Library
    const LIB_KEY = "capture_library_v2";

    /* =========================
       Resize draw layer
    ========================= */
    function resizeDrawLayer(){
      const r = stage.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      drawLayer.width  = Math.round(r.width * dpr);
      drawLayer.height = Math.round(r.height * dpr);
      drawLayer.style.width  = r.width + "px";
      drawLayer.style.height = r.height + "px";
      drawCtx.setTransform(dpr,0,0,dpr,0,0);
    }
    window.addEventListener("resize", resizeDrawLayer);

    function clearPathPreview(){
      drawCtx.clearRect(0,0, drawLayer.width, drawLayer.height);
    }
    function drawPathPreview(points){
      drawCtx.clearRect(0,0, drawLayer.width, drawLayer.height);
      if (!points || points.length < 2) return;
      drawCtx.beginPath();
      drawCtx.moveTo(points[0].x, points[0].y);
      for (const p of points) drawCtx.lineTo(p.x, p.y);
      drawCtx.lineWidth = 2;
      drawCtx.strokeStyle = "rgba(255,255,255,.65)";
      drawCtx.lineCap = "round";
      drawCtx.lineJoin = "round";
      drawCtx.stroke();
    }

    /* =========================
       Utility: clamp + local point
    ========================= */
    function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }

    function localPointFromClient(clientX, clientY){
      const r = stage.getBoundingClientRect();
      return { x: clientX - r.left, y: clientY - r.top, W: r.width, H: r.height };
    }
    function getClientXY(e){
      const cx = e.clientX ?? e.touches?.[0]?.clientX;
      const cy = e.clientY ?? e.touches?.[0]?.clientY;
      return { cx, cy };
    }

    /* =========================
       Camera
    ========================= */
    async function startCamera(){
      if (!navigator.mediaDevices?.getUserMedia) {
        alert("当前环境不支持摄像头。");
        return;
      }
      if (location.protocol !== "https:" && location.hostname !== "localhost" && location.hostname !== "127.0.0.1") {
        showHint("iOS 相机需要 HTTPS", 1400);
      }

      if (stream) stream.getTracks().forEach(t => t.stop());

      try{
        stream = await navigator.mediaDevices.getUserMedia({
          video: {
            facingMode,
            width:  { ideal: 720 },
            height: { ideal: 1280 }
          },
          audio: false
        });

        video.srcObject = stream;
        await video.play();

        video.style.transform = (facingMode === "user") ? "scaleX(-1)" : "none";

        loader.style.display = "none";
        resizeDrawLayer();

        showHint("轻点贴纸=选中；按住拖动=移动；双指=旋转缩放；Edit=深度编辑", 1800);
      } catch(e){
        console.error(e);
        alert("无法打开相机：请检查权限；iOS 通常需要 https。");
      }
    }

    /* =========================
       MediaPipe init (GPU -> CPU fallback)
    ========================= */
    async function initModel(){
      try{
        loader.innerText = "正在下载 WASM…";
        const vision = await FilesetResolver.forVisionTasks(
          "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
        );

        async function create(delegate){
          loader.innerText = `正在加载模型（${delegate}）…`;
          return await InteractiveSegmenter.createFromOptions(vision, {
            baseOptions: {
              modelAssetPath:
                "https://storage.googleapis.com/mediapipe-models/interactive_segmenter/magic_touch/float32/1/magic_touch.tflite",
              delegate
            },
            outputCategoryMask: true,
            outputConfidenceMasks: false
          });
        }

        try{
          interactiveSegmenter = await create("GPU");
          loader.innerText = "模型就绪（GPU），请开启相机";
        } catch(e){
          console.warn("GPU failed, fallback CPU:", e);
          interactiveSegmenter = await create("CPU");
          loader.innerText = "模型就绪（CPU），请开启相机";
        }
      } catch(err){
        console.error(err);
        loader.innerText = "模型加载失败: " + err.message;
      }
    }

    /* =========================
       Capture mode UI
    ========================= */
    const btnModeMP   = document.getElementById("btnModeMP");
    const btnModeRect = document.getElementById("btnModeRect");
    const btnModeDraw = document.getElementById("btnModeDraw");

    function setCaptureMode(m){
      captureMode = m;
      btnModeMP.classList.toggle("active", m==="mp");
      btnModeRect.classList.toggle("active", m==="rect");
      btnModeDraw.classList.toggle("active", m==="draw");

      if (m === "mp") showHint("MP：点一下物体自动抠图", 900);
      if (m === "rect") showHint("RECT：按住拖拽画框，松手截取", 900);
      if (m === "draw") showHint("DRAW：按住手写路径，松手截取", 900);
    }
    btnModeMP.onclick = () => setCaptureMode("mp");
    btnModeRect.onclick = () => setCaptureMode("rect");
    btnModeDraw.onclick = () => setCaptureMode("draw");

    /* =========================
       Selection + enable actions
    ========================= */
    function deselect(){
      if (selected?.el) selected.el.classList.remove("selected");
      selected = null;
      editbar.style.display = "none";
      paintUndoStack = [];
      setActionEnabled(false);
    }

    function selectSticker(st){
      if (selected && selected !== st) selected.el.classList.remove("selected");
      selected = st;
      st.el.classList.add("selected");
      paintUndoStack = [];
      setActionEnabled(true);
      showHint("已选中：可拖动移动 / Save / 双指旋转缩放 / Edit 深度编辑", 1200);
    }

    function applyTransform(st){
      st.el.style.transform = `translateZ(0) rotate(${st.rot}rad) scale(${st.scale})`;
    }

    /* =========================
       ROI box
    ========================= */
    function showROI(rect){
      roiBox.style.display = "block";
      roiBox.style.left = rect.x + "px";
      roiBox.style.top  = rect.y + "px";
      roiBox.style.width  = rect.w + "px";
      roiBox.style.height = rect.h + "px";
    }
    function hideROI(){ roiBox.style.display = "none"; }

    /* =========================
       object-fit: cover mapping
       stage CSS rect -> video pixel crop
    ========================= */
    function cssRectToVideoCrop(cssRect){
      const vw = video.videoWidth, vh = video.videoHeight;
      if (!vw || !vh) return null;

      const sw = stage.clientWidth, sh = stage.clientHeight;
      const videoAspect = vw / vh;
      const stageAspect = sw / sh;

      let drawW, drawH, offsetX, offsetY;
      if (stageAspect > videoAspect) {
        drawW = sw;
        drawH = sw / videoAspect;
        offsetX = 0;
        offsetY = (sh - drawH) / 2;
      } else {
        drawH = sh;
        drawW = sh * videoAspect;
        offsetY = 0;
        offsetX = (sw - drawW) / 2;
      }

      const isMirrored = (facingMode === "user");

      let nx = (cssRect.x - offsetX) / drawW;
      const ny = (cssRect.y - offsetY) / drawH;
      const nw = cssRect.w / drawW;
      const nh = cssRect.h / drawH;

      if (isMirrored) nx = 1 - nx - nw;

      let sx = Math.round(nx * vw);
      let sy = Math.round(ny * vh);
      let swp = Math.round(nw * vw);
      let shp = Math.round(nh * vh);

      sx = clamp(sx, 0, vw-1);
      sy = clamp(sy, 0, vh-1);
      swp = clamp(swp, 1, vw - sx);
      shp = clamp(shp, 1, vh - sy);

      return { sx, sy, sw: swp, sh: shp };
    }

    /* =========================
       Add sticker from canvas
    ========================= */
    function addStickerFromCanvas(srcCanvas, cssRect){
      const dpr = Math.max(1, Math.min(window.devicePixelRatio || 1, 3));

      const stCanvas = document.createElement("canvas");
      stCanvas.className = "sticker";
      stCanvas.style.left = cssRect.x + "px";
      stCanvas.style.top  = cssRect.y + "px";
      stCanvas.style.width  = cssRect.w + "px";
      stCanvas.style.height = cssRect.h + "px";

      stCanvas.width  = Math.round(cssRect.w * dpr);
      stCanvas.height = Math.round(cssRect.h * dpr);

      const ctx = stCanvas.getContext("2d");
      ctx.imageSmoothingEnabled = true;
      ctx.drawImage(srcCanvas, 0,0, stCanvas.width, stCanvas.height);

      stage.appendChild(stCanvas);

      const st = {
        el: stCanvas,
        x: cssRect.x, y: cssRect.y,
        w: cssRect.w, h: cssRect.h,
        scale: 1,
        rot: 0
      };
      stickers.push(st);
      objUndoStack.push(st);

      attachStickerInteractions(st);
      selectSticker(st);
    }

    /* =========================
       Hit testing / local points
    ========================= */
    function alphaHitTest(canvasEl, clientX, clientY){
      const r = canvasEl.getBoundingClientRect();
      const d = canvasEl.width / r.width;
      const px = (clientX - r.left) * d;
      const py = (clientY - r.top) * d;
      if (px < 0 || py < 0 || px >= canvasEl.width || py >= canvasEl.height) return false;
      const a = canvasEl.getContext("2d").getImageData(px|0, py|0, 1, 1).data[3];
      return a !== 0;
    }

    function getLocalPointOnCanvas(canvasEl, clientX, clientY){
      const r = canvasEl.getBoundingClientRect();
      if (clientX < r.left || clientX > r.right || clientY < r.top || clientY > r.bottom) return null;
      const x = (clientX - r.left) / r.width * canvasEl.width;
      const y = (clientY - r.top) / r.height * canvasEl.height;
      return { x, y };
    }

    /* =========================
       Sticker interactions
       - tap: select
       - press+drag: move (when NOT editing)
       - drag: liquify (when editing)
    ========================= */
    function attachStickerInteractions(st){
      const el = st.el;

      let isDown = false;
      let startX=0, startY=0;
      let baseLeft=0, baseTop=0;
      let moved = false;
      const DRAG_THRESHOLD = 6; // px
      let lastLocal = null;

      el.addEventListener("pointerdown", (e)=>{
        if (!alphaHitTest(el, e.clientX, e.clientY)) return;

        e.preventDefault();
        e.stopPropagation();

        isDown = true;
        moved = false;

        startX = e.clientX;
        startY = e.clientY;
        baseLeft = st.x;
        baseTop  = st.y;

        // tap/drag都会先选中
        selectSticker(st);

        // deep edit snapshot only if editing
        if (editbar.style.display === "flex" && editMode === "stretch") {
          lastLocal = getLocalPointOnCanvas(el, e.clientX, e.clientY);

          const ctx = el.getContext("2d");
          const snap = ctx.getImageData(0,0, el.width, el.height);
          paintUndoStack.push(snap);
          if (paintUndoStack.length > 14) paintUndoStack.shift();
        } else {
          lastLocal = null;
        }

        el.setPointerCapture(e.pointerId);
      }, { passive:false });

      el.addEventListener("pointermove", (e)=>{
        if (!isDown || selected !== st) return;

        const dx = e.clientX - startX;
        const dy = e.clientY - startY;
        const dist = Math.hypot(dx, dy);

        // NOT editing: drag to move
        if (editbar.style.display !== "flex") {
          if (dist > DRAG_THRESHOLD) moved = true;
          if (!moved) return;

          st.x = baseLeft + dx;
          st.y = baseTop  + dy;
          el.style.left = st.x + "px";
          el.style.top  = st.y + "px";
          e.preventDefault();
          return;
        }

        // Editing: drag to liquify
        if (editMode !== "stretch") return;
        const local = getLocalPointOnCanvas(el, e.clientX, e.clientY);
        if (!local) return;

        const radius = parseInt(radiusEl.value, 10);
        const base = parseInt(strengthEl.value, 10) / 100;
        const strength = Math.max(-1.25, Math.min(1.25, base * 1.35));

        if (lastLocal){
          const vx = local.x - lastLocal.x;
          const vy = local.y - lastLocal.y;
          applySmear(el, local.x, local.y, radius, vx, vy, strength);
        }
        lastLocal = local;

        e.preventDefault();
      }, { passive:false });

      const end = (e)=>{
        isDown = false;
        lastLocal = null;
        moved = false;
        try{ el.releasePointerCapture(e.pointerId); }catch{}
      };
      el.addEventListener("pointerup", end);
      el.addEventListener("pointercancel", end);
    }

    /* =========================
       Smear / Liquify
    ========================= */
    function applySmear(canvas, cx, cy, radius, vx, vy, strength){
      const ctx = canvas.getContext("2d");
      const w = canvas.width, h = canvas.height;

      const src = ctx.getImageData(0,0,w,h);
      const dst = ctx.createImageData(w,h);
      dst.data.set(src.data);

      const r2 = radius * radius;

      const x0 = Math.max(0, Math.floor(cx - radius));
      const x1 = Math.min(w - 1, Math.ceil(cx + radius));
      const y0 = Math.max(0, Math.floor(cy - radius));
      const y1 = Math.min(h - 1, Math.ceil(cy + radius));

      const len = Math.hypot(vx, vy) || 1;
      const ux = vx / len;
      const uy = vy / len;

      const push = Math.min(36, len) * (0.9 + Math.abs(strength) * 1.3) * Math.sign(strength || 1);

      for (let y = y0; y <= y1; y++){
        for (let x = x0; x <= x1; x++){
          const dx = x - cx, dy = y - cy;
          const d2 = dx*dx + dy*dy;
          if (d2 > r2) continue;

          const d = Math.sqrt(d2);
          const t = 1 - d / radius;
          const falloff = t * t;

          const sx = x - ux * push * falloff;
          const sy = y - uy * push * falloff;

          const ix = Math.max(0, Math.min(w - 1, Math.round(sx)));
          const iy = Math.max(0, Math.min(h - 1, Math.round(sy)));

          const si = (iy*w + ix)*4;
          const di = (y*w + x)*4;

          dst.data[di]     = src.data[si];
          dst.data[di + 1] = src.data[si + 1];
          dst.data[di + 2] = src.data[si + 2];
          dst.data[di + 3] = src.data[si + 3];
        }
      }
      ctx.putImageData(dst, 0,0);
    }

    /* =========================
       Two-finger transform (rotate/scale) on selected
    ========================= */
    stage.addEventListener("touchstart", (e)=>{
      if (!selected) return;
      if (e.touches.length === 2){
        e.preventDefault();
        const t1 = e.touches[0], t2 = e.touches[1];
        const dx = t2.clientX - t1.clientX;
        const dy = t2.clientY - t1.clientY;
        gesture.active = true;
        gesture.startDist = Math.hypot(dx,dy);
        gesture.startAng  = Math.atan2(dy,dx);
        gesture.baseScale = selected.scale;
        gesture.baseRot   = selected.rot;
      }
    }, { passive:false });

    stage.addEventListener("touchmove", (e)=>{
      if (!gesture.active || !selected) return;
      if (e.touches.length !== 2) return;
      e.preventDefault();

      const t1 = e.touches[0], t2 = e.touches[1];
      const dx = t2.clientX - t1.clientX;
      const dy = t2.clientY - t1.clientY;

      const dist = Math.hypot(dx,dy);
      const ang  = Math.atan2(dy,dx);

      const scale = gesture.baseScale * (dist / Math.max(1, gesture.startDist));
      const rot   = gesture.baseRot + (ang - gesture.startAng);

      selected.scale = clamp(scale, 0.2, 6);
      selected.rot = rot;
      applyTransform(selected);
    }, { passive:false });

    stage.addEventListener("touchend", ()=>{ gesture.active = false; });
    stage.addEventListener("touchcancel", ()=>{ gesture.active = false; });

    /* =========================
       Stage interactions
       - tap empty: deselect (if not editing)
       - MP tap: segment
       - RECT/DRAW: ROI capture
    ========================= */
    stage.addEventListener("pointerdown", (e)=>{
      if (e.target.closest(".topbar") || e.target.closest("#editbar") || e.target.closest("#libPanel")) return;

      if (!video.srcObject) { showHint("先点 Start Camera", 900); return; }

      const isOnStageSurface = (e.target === stage || e.target === video || e.target === roiBox || e.target === drawLayer);
      if (!isOnStageSurface) return;

      // If editing: tap empty exits editing (keep selected)
      if (editbar.style.display === "flex") {
        editbar.style.display = "none";
        paintUndoStack = [];
        showHint("退出深度编辑", 800);
        return;
      }

      // if selected and tap empty -> deselect
      if (selected){
        deselect();
        showHint("取消选中", 700);
        return;
      }

      // MP mode: tap to segment
      if (captureMode === "mp"){
        handleMediaPipeTap(e);
        return;
      }

      // RECT / DRAW: begin ROI
      e.preventDefault();
      pointerDown = true;

      const p = localPointFromClient(e.clientX, e.clientY);
      startPt = p;

      roi = { x:p.x, y:p.y, w:1, h:1 };
      path = [ {x:p.x, y:p.y} ];

      showROI(roi);
      if (captureMode === "draw") drawPathPreview(path);
    }, { passive:false });

    stage.addEventListener("pointermove", (e)=>{
      if (!pointerDown || !startPt) return;
      e.preventDefault();

      const p = localPointFromClient(e.clientX, e.clientY);

      if (captureMode === "rect"){
        const x = Math.min(startPt.x, p.x);
        const y = Math.min(startPt.y, p.y);
        const w = Math.abs(p.x - startPt.x);
        const h = Math.abs(p.y - startPt.y);
        roi = {
          x: clamp(x, 0, startPt.W-1),
          y: clamp(y, 0, startPt.H-1),
          w: clamp(w, 1, startPt.W),
          h: clamp(h, 1, startPt.H)
        };
        showROI(roi);
      } else if (captureMode === "draw"){
        path.push({x:p.x, y:p.y});
        let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
        for (const pt of path){
          minX = Math.min(minX, pt.x); minY = Math.min(minY, pt.y);
          maxX = Math.max(maxX, pt.x); maxY = Math.max(maxY, pt.y);
        }
        roi = { x:minX, y:minY, w:(maxX-minX), h:(maxY-minY) };
        showROI(roi);
        drawPathPreview(path);
      }
    }, { passive:false });

    stage.addEventListener("pointerup", async (e)=>{
      if (!pointerDown) return;
      e.preventDefault();
      pointerDown = false;

      if (!roi || roi.w < 8 || roi.h < 8){
        hideROI();
        roi = null; path = []; startPt = null;
        clearPathPreview();
        return;
      }

      if (captureMode === "rect"){
        await createStickerFromROI(roi, null);
      } else if (captureMode === "draw"){
        await createStickerFromROI(roi, (path.length>=2 ? path : null));
      }

      hideROI();
      roi = null; path = []; startPt = null;
      clearPathPreview();
    }, { passive:false });

    stage.addEventListener("pointercancel", ()=>{
      pointerDown = false;
      hideROI();
      roi = null; path = []; startPt = null;
      clearPathPreview();
    });

    /* =========================
       Create sticker from ROI (RECT/DRAW)
    ========================= */
    async function createStickerFromROI(rect, pathPoints){
      const crop = cssRectToVideoCrop(rect);
      if (!crop) return;

      const dpr = Math.max(1, Math.min(window.devicePixelRatio || 1, 3));
      const src = document.createElement("canvas");
      src.width  = Math.round(rect.w * dpr);
      src.height = Math.round(rect.h * dpr);
      const ctx = src.getContext("2d");
      ctx.imageSmoothingEnabled = true;
      ctx.clearRect(0,0,src.width, src.height);

      if (pathPoints && pathPoints.length >= 2){
        ctx.save();
        ctx.scale(dpr, dpr);
        ctx.beginPath();
        ctx.moveTo(pathPoints[0].x - rect.x, pathPoints[0].y - rect.y);
        for (const p of pathPoints) ctx.lineTo(p.x - rect.x, p.y - rect.y);
        ctx.closePath();
        ctx.clip();

        ctx.drawImage(
          video,
          crop.sx, crop.sy, crop.sw, crop.sh,
          0, 0, rect.w * dpr, rect.h * dpr
        );
        ctx.restore();
      } else {
        ctx.drawImage(
          video,
          crop.sx, crop.sy, crop.sw, crop.sh,
          0, 0, src.width, src.height
        );
      }

      addStickerFromCanvas(src, rect);
      showHint("截取完成：按住拖动移动；双指旋转缩放；Edit 深度编辑", 1200);
    }

    /* =========================
       MediaPipe tap -> segment -> trimmed sticker
    ========================= */
    async function handleMediaPipeTap(e){
      if (!interactiveSegmenter) { showHint("模型未就绪", 800); return; }
      if (isProcessing) return;

      const rect = video.getBoundingClientRect();
      const { cx: clientX, cy: clientY } = getClientXY(e);
      if (clientX == null || clientY == null) return;

      if (clientX < rect.left || clientX > rect.right || clientY < rect.top || clientY > rect.bottom) return;

      isProcessing = true;
      try{
        const relativeX = (clientX - rect.left) / rect.width;
        const relativeY = (clientY - rect.top) / rect.height;

        const result = await new Promise(resolve => {
          interactiveSegmenter.segment(
            video,
            { keypoint: { x: relativeX, y: relativeY } },
            (r)=>resolve(r)
          );
        });

        if (!result?.categoryMask){
          showHint("没有得到 mask（换个点试试）", 900);
          isProcessing = false;
          return;
        }

        const w = video.videoWidth;
        const h = video.videoHeight;

        const full = document.createElement("canvas");
        full.width = w;
        full.height = h;
        const fctx = full.getContext("2d");
        fctx.drawImage(video, 0,0,w,h);

        const imgData = fctx.getImageData(0,0,w,h);
        const pixels = imgData.data;
        const maskData = result.categoryMask.getAsFloat32Array();

        for (let i=0;i<maskData.length;i++){
          if (maskData[i] < 0.4) pixels[i*4+3] = 0;
        }
        fctx.putImageData(imgData, 0,0);

        const trimmed = trimCanvas(full);
        if (!trimmed){
          showHint("抠图为空（换个点试试）", 900);
          isProcessing = false;
          return;
        }

        // map video pixels -> stage css px (object-fit cover)
        const sw = stage.clientWidth, sh = stage.clientHeight;
        const videoAspect = w / h;
        const stageAspect = sw / sh;

        let drawW, drawH, offsetX, offsetY;
        if (stageAspect > videoAspect){
          drawW = sw;
          drawH = sw / videoAspect;
          offsetX = 0;
          offsetY = (sh - drawH)/2;
        } else {
          drawH = sh;
          drawW = sh * videoAspect;
          offsetY = 0;
          offsetX = (sw - drawW)/2;
        }

        let nx = trimmed.dataset.originX / w;
        const ny = trimmed.dataset.originY / h;
        const nw = trimmed.width / w;
        const nh = trimmed.height / h;

        if (facingMode === "user"){
          nx = 1 - nx - nw;
        }

        const cssRect = {
          x: offsetX + nx * drawW,
          y: offsetY + ny * drawH,
          w: nw * drawW,
          h: nh * drawH
        };

        addStickerFromCanvas(trimmed, cssRect);
        showHint("MP 抠图完成：按住拖动移动；双指旋转缩放；Edit 深度编辑", 1300);
      } catch(err){
        console.error(err);
        showHint("分割出错（可能网络/模型/权限）", 1200);
      }
      isProcessing = false;
    }

    function trimCanvas(c){
      const ctx = c.getContext("2d");
      const pixels = ctx.getImageData(0,0,c.width,c.height);
      const l = pixels.data.length;
      let bound = { top:null, left:null, right:null, bottom:null };
      let x,y;

      for (let i=0;i<l;i+=4){
        if (pixels.data[i+3] !== 0){
          x = (i/4) % c.width;
          y = ~~((i/4) / c.width);
          if (bound.top === null) bound.top = y;
          if (bound.left === null) bound.left = x;
          else if (x < bound.left) bound.left = x;

          if (bound.right === null) bound.right = x;
          else if (bound.right < x) bound.right = x;

          if (bound.bottom === null) bound.bottom = y;
          else if (bound.bottom < y) bound.bottom = y;
        }
      }
      if (bound.top === null) return null;

      const trimW = bound.right - bound.left + 1;
      const trimH = bound.bottom - bound.top + 1;

      const out = document.createElement("canvas");
      out.width = trimW;
      out.height = trimH;
      out.getContext("2d").drawImage(c, bound.left, bound.top, trimW, trimH, 0,0, trimW, trimH);

      out.dataset.originX = bound.left;
      out.dataset.originY = bound.top;
      return out;
    }

    /* =========================
       Library
    ========================= */
    function loadLibrary(){
      try{ return JSON.parse(localStorage.getItem(LIB_KEY) || "[]"); }
      catch{ return []; }
    }
    function saveLibrary(items){
      localStorage.setItem(LIB_KEY, JSON.stringify(items));
    }
    function refreshLibraryUI(){
      const items = loadLibrary();
      libList.innerHTML = "";
      if (!items.length){
        libList.innerHTML = `<div class="small" style="opacity:.7;">(empty)</div>`;
        return;
      }
      items.forEach((it, idx)=>{
        const img = document.createElement("img");
        img.className = "thumb";
        img.src = it.dataURL;
        img.title = `#${idx+1}`;
        img.addEventListener("click", ()=>{
          addStickerFromDataURL(it.dataURL, it.w, it.h);
        });
        libList.appendChild(img);
      });
    }

    async function addStickerFromDataURL(dataURL, w, h){
      const img = new Image();
      img.src = dataURL;
      await img.decode().catch(()=>{});

      const rect = stage.getBoundingClientRect();
      const targetW = clamp(w || 160, 60, rect.width * 0.8);
      const targetH = clamp(h || 120, 60, rect.height* 0.8);

      const x = (rect.width - targetW)/2;
      const y = (rect.height - targetH)/2;

      const src = document.createElement("canvas");
      src.width = img.naturalWidth || 512;
      src.height = img.naturalHeight || 512;
      const ctx = src.getContext("2d");
      ctx.drawImage(img, 0,0, src.width, src.height);

      addStickerFromCanvas(src, { x, y, w: targetW, h: targetH });
      showHint("已从 Library 放回舞台", 900);
    }

    function stickerToDataURL(st){
      return st.el.toDataURL("image/png");
    }

    /* =========================
       Topbar buttons
    ========================= */
    document.getElementById("btnStart").addEventListener("click", startCamera);

    document.getElementById("btnFlip").addEventListener("click", async ()=>{
      facingMode = (facingMode === "environment") ? "user" : "environment";
      await startCamera();
      showHint(facingMode === "user" ? "前置（镜像）" : "后置", 700);
    });

    btnSave.addEventListener("click", ()=>{
      if (!selected) return;

      const items = loadLibrary();
      items.unshift({
        dataURL: stickerToDataURL(selected),
        w: selected.w,
        h: selected.h,
        t: Date.now()
      });
      saveLibrary(items.slice(0, 60));
      refreshLibraryUI();
      showHint("已保存到 Library", 900);
    });

    btnEdit.addEventListener("click", ()=>{
      if (!selected) return;
      editbar.style.display = "flex";
      paintUndoStack = [];
      showHint("进入深度编辑：拖动=拉伸；双指=旋转缩放；Done 退出", 1300);
    });

    document.getElementById("btnUndoPaint").addEventListener("click", ()=>{
      if (!selected || paintUndoStack.length === 0) return;
      const prev = paintUndoStack.pop();
      const ctx = selected.el.getContext("2d");
      ctx.putImageData(prev, 0, 0);
      showHint("撤销", 650);
    });

    document.getElementById("btnDone").addEventListener("click", ()=>{
      editbar.style.display = "none";
      paintUndoStack = [];
      showHint("退出深度编辑", 800);
    });

    document.getElementById("btnLibrary").addEventListener("click", ()=>{
      libPanel.style.display = (!libPanel.style.display || libPanel.style.display === "none") ? "block" : "none";
      refreshLibraryUI();
    });

    document.getElementById("btnLibClose").addEventListener("click", ()=>{
      libPanel.style.display = "none";
    });

    document.getElementById("btnLibClear").addEventListener("click", ()=>{
      if (!confirm("Clear library?")) return;
      saveLibrary([]);
      refreshLibraryUI();
    });

    document.getElementById("btnUndoObj").addEventListener("click", ()=>{
      const last = objUndoStack.pop();
      if (!last) return;
      if (selected === last) deselect();
      last.el.remove();
      stickers = stickers.filter(s => s !== last);
      showHint("撤销新增（删除最后一个）", 850);
    });

    document.getElementById("btnClearAll").addEventListener("click", ()=>{
      stickers.forEach(s => s.el.remove());
      stickers = [];
      objUndoStack = [];
      deselect();
      showHint("已清空", 800);
    });

    /* =========================
       Save/Edit initial disabled
    ========================= */
    setActionEnabled(false);

    /* =========================
       Defaults + init
    ========================= */
    setCaptureMode("mp");
    resizeDrawLayer();
    refreshLibraryUI();
    initModel();
  </script>
</body>
</html>
